1. В чём отличие динамического массива от статического массива в C++?

Статический массив имеет размер, который известен заранее, и создаётся автоматически. Его нельзя изменить во время работы программы.

Динамический массив создаётся во время выполнения, размер можно задать программно. Память под него выделяется вручную и её нужно потом освободить.

2. Что такое указатель и зачем он нужен при работе с динамической памятью?

Указатель хранит адрес области памяти.

Когда мы выделяем динамическую память, мы получаем именно адрес этой памяти, поэтому без указателя к ней нельзя обратиться и работать с элементами массива.

3. Почему важно освобождать динамическую память после использования?

Если не освобождать память, она остаётся занятой даже после того, как массив больше не нужен.

Со временем это приводит к утечкам памяти и ухудшению работы программы, особенно если выделение происходит в цикле или в больших объёмах.

4. В чём разница между последовательной и параллельной обработкой массива?

При последовательной обработке массив обрабатывается одним потоком, элементы идут строго один за другим.

При параллельной обработке массив делится на части, которые обрабатываются разными потоками одновременно, что позволяет ускорить вычисления на многоядерных процессорах.

5. Что делает директива #pragma omp parallel for?

Эта директива говорит компилятору, что цикл for можно выполнять параллельно.

OpenMP сам разбивает итерации цикла между потоками и запускает их одновременно.

6. Для чего используется reduction в OpenMP?

reduction нужен, когда несколько потоков считают общий результат, например сумму или минимум.

Он позволяет каждому потоку считать свой локальный результат, а потом корректно объединить их в одно итоговое значение.

7. Почему при параллельном вычислении суммы нельзя использовать обычную переменную?

Если все потоки будут одновременно менять одну и ту же переменную, результат будет некорректным из-за гонки данных.

reduction решает эту проблему, потому что у каждого потока есть своя копия переменной, и только в конце они аккуратно суммируются.

8. Почему параллельная версия может работать медленнее последовательной?

Параллельность не всегда даёт ускорение.

Если данных мало, есть большие накладные расходы на потоки, или часто происходит синхронизация, то параллельная версия может оказаться даже медленнее обычной последовательной.
