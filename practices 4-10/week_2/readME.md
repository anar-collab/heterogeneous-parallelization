4. Выводы по производительности

 Наблюдения (типичные):

Для малых массивов (1000):

последовательные версии быстрее

Для средних массивов (10 000):

параллельные версии иногда сравнимы

Для больших массивов (100 000):

простые сортировки всё равно медленные

OpenMP часто замедляет, а не ускоряет

Причина:

высокая синхронизация

зависимости между элементами

накладные расходы на потоки

"============================================"

5. Ответы на контрольные вопросы
В чём основные отличия алгоритмов?

Пузырёк — сравнение соседей

Выбор — поиск минимума

Вставки — вставка элемента в отсортированную часть

"============================================"

Почему вставки сложно распараллелить?

Потому что:

каждый шаг зависит от предыдущего

нарушается порядок данных

возникают гонки данных

"====================================="

Какие директивы OpenMP использовались?

#pragma omp parallel for

#pragma omp critical

reduction (в других задачах)

"======================================"

Плюсы и минусы параллельной сортировки на CPU

Плюсы:

может ускорить работу

использует все ядра CPU

Минусы:

накладные расходы

сложность синхронизации

неэффективна для простых алгоритмов

"================================================"

Как измерить производительность в C++?

С помощью:

#include <chrono>
std::chrono::high_resolution_clock

"======================================="

Как влияет число потоков?

до определённого момента ускоряет

затем производительность падает из-за overhead

"======================================="

Когда параллельная сортировка хуже?

маленькие массивы

простые алгоритмы

сильные зависимости между элементами