1. В чём основные отличия между массивами и динамическими структурами данных?

Массивы имеют фиксированный размер и размещаются в памяти последовательно, что обеспечивает быстрый доступ по индексу.
Динамические структуры данных (списки, стеки, очереди) могут изменять размер во время выполнения программы и обычно используют указатели для связи элементов, но доступ к элементам у них медленнее.

2. Что такое указатель, и как он используется в языке C++?

Указатель — это переменная, которая хранит адрес другой переменной в памяти. В C++ указатели используются для работы с динамической памятью, передачи данных в функции без копирования и построения динамических структур данных, таких как списки и деревья.

3. Объясните принцип работы стека и очереди.

Стек работает по принципу LIFO (Last In – First Out): последний добавленный элемент извлекается первым.
Очередь работает по принципу FIFO (First In – First Out): первый добавленный элемент извлекается первым.
Обе структуры часто используются для организации данных и управления порядком выполнения операций.

4. Каковы преимущества и недостатки односвязных списков по сравнению с массивами?

Преимущества односвязных списков:

динамический размер;

быстрое добавление и удаление элементов.

Недостатки:

отсутствие прямого доступа по индексу;

дополнительные затраты памяти на хранение указателей;

более медленный доступ к элементам по сравнению с массивами.

5. Как правильно освобождать память в языке C++ после работы с динамическими структурами?

Память, выделенную с помощью new, необходимо освобождать оператором delete, а память, выделенную с помощью new[], — оператором delete[].
Важно освобождать всю динамически выделенную память, чтобы избежать утечек, и после удаления желательно обнулять указатели.

6. Почему важно понимать работу с указателями и динамической памятью для параллельного программирования?

В параллельном программировании несколько потоков могут одновременно работать с одной и той же памятью. Если неправильно управлять указателями и динамической памятью, это может привести к гонкам данных, утечкам памяти и ошибкам синхронизации. Понимание этих механизмов помогает писать безопасный и корректный параллельный код.

7. Как использовать reduction в OpenMP для нахождения суммы, минимума или максимума в массиве?

Механизм reduction позволяет каждому потоку работать со своей локальной копией переменной, а затем автоматически объединять результаты. Например, для суммы используется reduction(+:sum), для минимума — reduction(min:min_val), а для максимума — reduction(max:max_val).

8. Как влияет параллельное программирование на производительность при работе с большими массивами?

При работе с большими массивами параллельное программирование позволяет распределить вычисления между несколькими ядрами, что обычно приводит к ускорению выполнения. Однако эффективность зависит от структуры алгоритма, объёма данных и накладных расходов на синхронизацию потоков.
